; ModuleID = 'LLVMDialectModule'
source_filename = "LLVMDialectModule"

declare void @memrefCopy(i64, ptr, ptr)

declare ptr @malloc(i64)

define void @load_load(i64 %0, ptr %1, i64 %2, ptr %3, i64 %4, ptr %5, i32 %6, i32 %7, i32 %8, i32 %9, i32 %10, i32 %11, i32 %12, i32 %13, i32 %14) {
  %16 = insertvalue { i64, ptr } poison, i64 %4, 0
  %17 = insertvalue { i64, ptr } %16, ptr %5, 1
  %18 = insertvalue { i64, ptr } poison, i64 %2, 0
  %19 = insertvalue { i64, ptr } %18, ptr %3, 1
  %20 = insertvalue { i64, ptr } poison, i64 %0, 0
  %21 = insertvalue { i64, ptr } %20, ptr %1, 1
  %22 = call ptr @malloc(i64 4160)
  %23 = ptrtoint ptr %22 to i64
  %24 = add i64 %23, 63
  %25 = urem i64 %24, 64
  %26 = sub i64 %24, %25
  %27 = inttoptr i64 %26 to ptr
  %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %22, 0
  %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1
  %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2
  %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 1024, 3, 0
  %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0
  br label %33

33:                                               ; preds = %36, %15
  %34 = phi i64 [ %38, %36 ], [ 0, %15 ]
  %35 = icmp slt i64 %34, 1024
  br i1 %35, label %36, label %39

36:                                               ; preds = %33
  %37 = getelementptr inbounds nuw float, ptr %27, i64 %34
  store float 2.000000e+00, ptr %37, align 4
  %38 = add i64 %34, 1
  br label %33

39:                                               ; preds = %33
  %40 = mul i32 %12, 1024
  %41 = sext i32 %40 to i64
  %42 = extractvalue { i64, ptr } %19, 1
  %43 = load ptr, ptr %42, align 8
  %44 = getelementptr ptr, ptr %42, i32 1
  %45 = load ptr, ptr %44, align 8
  %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %43, 0
  %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, ptr %45, 1
  %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 %41, 2
  %49 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, i64 1024, 3, 0
  %50 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, i64 1, 4, 0
  %51 = add i64 %41, 1024
  %52 = sext i32 %6 to i64
  %53 = call i64 @llvm.smin.i64(i64 %51, i64 %52)
  %54 = call i64 @llvm.smax.i64(i64 %53, i64 %41)
  %55 = sub i64 %54, %41
  %56 = call ptr @malloc(i64 4096)
  %57 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %56, 0
  %58 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, ptr %56, 1
  %59 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, i64 0, 2
  %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, i64 1024, 3, 0
  %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, i64 1, 4, 0
  %62 = insertvalue { ptr, ptr, i64 } poison, ptr %43, 0
  %63 = insertvalue { ptr, ptr, i64 } %62, ptr %45, 1
  %64 = insertvalue { ptr, ptr, i64 } %63, i64 0, 2
  %65 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %43, 0
  %66 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %65, ptr %45, 1
  %67 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, i64 %41, 2
  %68 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, i64 %55, 3, 0
  %69 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, i64 1, 4, 0
  %70 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %56, 0
  %71 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, ptr %56, 1
  %72 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %71, i64 0, 2
  %73 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %72, i64 %55, 3, 0
  %74 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %73, i64 1, 4, 0
  %75 = call ptr @llvm.stacksave.p0()
  %76 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, ptr %76, align 8
  %77 = insertvalue { i64, ptr } { i64 1, ptr poison }, ptr %76, 1
  %78 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %74, ptr %78, align 8
  %79 = insertvalue { i64, ptr } { i64 1, ptr poison }, ptr %78, 1
  %80 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %77, ptr %80, align 8
  %81 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %79, ptr %81, align 8
  call void @memrefCopy(i64 4, ptr %80, ptr %81)
  call void @llvm.stackrestore.p0(ptr %75)
  %82 = call ptr @malloc(i64 4096)
  %83 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %82, 0
  %84 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %83, ptr %82, 1
  %85 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, i64 0, 2
  %86 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, i64 1024, 3, 0
  %87 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, i64 1, 4, 0
  %88 = icmp slt i64 %55, 1024
  br i1 %88, label %89, label %97

89:                                               ; preds = %39
  br label %90

90:                                               ; preds = %93, %89
  %91 = phi i64 [ %95, %93 ], [ 0, %89 ]
  %92 = icmp slt i64 %91, 1024
  br i1 %92, label %93, label %96

93:                                               ; preds = %90
  %94 = getelementptr inbounds nuw float, ptr %82, i64 %91
  store float 0.000000e+00, ptr %94, align 4
  %95 = add i64 %91, 1
  br label %90

96:                                               ; preds = %90
  br label %97

97:                                               ; preds = %96, %39
  %98 = call i64 @llvm.smin.i64(i64 %55, i64 1024)
  br label %99

99:                                               ; preds = %102, %97
  %100 = phi i64 [ %122, %102 ], [ 0, %97 ]
  %101 = icmp slt i64 %100, %98
  br i1 %101, label %102, label %123

102:                                              ; preds = %99
  %103 = getelementptr inbounds nuw i32, ptr %56, i64 %100
  %104 = load i32, ptr %103, align 4
  %105 = sext i32 %104 to i64
  %106 = extractvalue { i64, ptr } %21, 1
  %107 = load ptr, ptr %106, align 8
  %108 = getelementptr ptr, ptr %106, i32 1
  %109 = load ptr, ptr %108, align 8
  %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %107, 0
  %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, ptr %109, 1
  %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 %105, 2
  %113 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %112, i64 1, 3, 0
  %114 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %113, i64 1, 4, 0
  %115 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %82, 0
  %116 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %115, ptr %82, 1
  %117 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %116, i64 %100, 2
  %118 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %117, i64 1, 3, 0
  %119 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %118, i64 1, 4, 0
  %120 = getelementptr float, ptr %109, i64 %105
  %121 = getelementptr float, ptr %82, i64 %100
  call void @llvm.memcpy.p0.p0.i64(ptr %121, ptr %120, i64 4, i1 false)
  %122 = add i64 %100, 1
  br label %99

123:                                              ; preds = %99
  br label %124

124:                                              ; preds = %127, %123
  %125 = phi i64 [ %134, %127 ], [ 0, %123 ]
  %126 = icmp slt i64 %125, 1024
  br i1 %126, label %127, label %135

127:                                              ; preds = %124
  %128 = getelementptr inbounds nuw float, ptr %82, i64 %125
  %129 = load float, ptr %128, align 4
  %130 = getelementptr inbounds nuw float, ptr %27, i64 %125
  %131 = load float, ptr %130, align 4
  %132 = fmul float %129, %131
  %133 = getelementptr inbounds nuw float, ptr %82, i64 %125
  store float %132, ptr %133, align 4
  %134 = add i64 %125, 1
  br label %124

135:                                              ; preds = %124
  %136 = extractvalue { i64, ptr } %17, 1
  %137 = load ptr, ptr %136, align 8
  %138 = getelementptr ptr, ptr %136, i32 1
  %139 = load ptr, ptr %138, align 8
  %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %137, 0
  %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1
  %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 %41, 2
  %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 1024, 3, 0
  %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0
  %145 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %82, 0
  %146 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %145, ptr %82, 1
  %147 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %146, i64 0, 2
  %148 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %147, i64 %55, 3, 0
  %149 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %148, i64 1, 4, 0
  %150 = insertvalue { ptr, ptr, i64 } poison, ptr %137, 0
  %151 = insertvalue { ptr, ptr, i64 } %150, ptr %139, 1
  %152 = insertvalue { ptr, ptr, i64 } %151, i64 0, 2
  %153 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %137, 0
  %154 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %153, ptr %139, 1
  %155 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %154, i64 %41, 2
  %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %155, i64 %55, 3, 0
  %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, i64 1, 4, 0
  %158 = call ptr @llvm.stacksave.p0()
  %159 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %149, ptr %159, align 8
  %160 = insertvalue { i64, ptr } { i64 1, ptr poison }, ptr %159, 1
  %161 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, ptr %161, align 8
  %162 = insertvalue { i64, ptr } { i64 1, ptr poison }, ptr %161, 1
  %163 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %160, ptr %163, align 8
  %164 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %162, ptr %164, align 8
  call void @memrefCopy(i64 4, ptr %163, ptr %164)
  call void @llvm.stackrestore.p0(ptr %158)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smin.i64(i64, i64) #0

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smax.i64(i64, i64) #0

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #1

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore.p0(ptr) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias writeonly captures(none), ptr noalias readonly captures(none), i64, i1 immarg) #2

attributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #1 = { nocallback nofree nosync nounwind willreturn }
attributes #2 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
