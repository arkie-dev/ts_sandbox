; ModuleID = 'LLVMDialectModule'
source_filename = "LLVMDialectModule"

declare void @memrefCopy(i64, ptr, ptr)

declare ptr @malloc(i64)

define void @load(i64 %0, ptr %1, i64 %2, ptr %3, i64 %4, ptr %5, i32 %6, i32 %7, i32 %8, i32 %9, i32 %10, i32 %11, i32 %12) {
  %14 = insertvalue { i64, ptr } poison, i64 %4, 0
  %15 = insertvalue { i64, ptr } %14, ptr %5, 1
  %16 = insertvalue { i64, ptr } poison, i64 %0, 0
  %17 = insertvalue { i64, ptr } %16, ptr %1, 1
  %18 = call ptr @malloc(i64 192)
  %19 = ptrtoint ptr %18 to i64
  %20 = add i64 %19, 63
  %21 = urem i64 %20, 64
  %22 = sub i64 %20, %21
  %23 = inttoptr i64 %22 to ptr
  %24 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %18, 0
  %25 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, ptr %23, 1
  %26 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, i64 0, 2
  %27 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %26, i64 32, 3, 0
  %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %27, i64 1, 4, 0
  br label %29

29:                                               ; preds = %32, %13
  %30 = phi i64 [ %34, %32 ], [ 0, %13 ]
  %31 = icmp slt i64 %30, 32
  br i1 %31, label %32, label %35

32:                                               ; preds = %29
  %33 = getelementptr inbounds nuw float, ptr %23, i64 %30
  store float 2.000000e+00, ptr %33, align 4
  %34 = add i64 %30, 1
  br label %29

35:                                               ; preds = %29
  %36 = mul i32 %10, 32
  %37 = sext i32 %36 to i64
  %38 = extractvalue { i64, ptr } %17, 1
  %39 = load ptr, ptr %38, align 8
  %40 = getelementptr ptr, ptr %38, i32 1
  %41 = load ptr, ptr %40, align 8
  %42 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %39, 0
  %43 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, ptr %41, 1
  %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, i64 %37, 2
  %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, i64 32, 3, 0
  %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 1, 4, 0
  %47 = add i64 %37, 32
  %48 = sext i32 %6 to i64
  %49 = call i64 @llvm.smin.i64(i64 %47, i64 %48)
  %50 = call i64 @llvm.smax.i64(i64 %49, i64 %37)
  %51 = sub i64 %50, %37
  %52 = call ptr @malloc(i64 128)
  %53 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %52, 0
  %54 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %53, ptr %52, 1
  %55 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %54, i64 0, 2
  %56 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %55, i64 32, 3, 0
  %57 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %56, i64 1, 4, 0
  %58 = icmp slt i64 %51, 32
  br i1 %58, label %59, label %67

59:                                               ; preds = %35
  br label %60

60:                                               ; preds = %63, %59
  %61 = phi i64 [ %65, %63 ], [ 0, %59 ]
  %62 = icmp slt i64 %61, 32
  br i1 %62, label %63, label %66

63:                                               ; preds = %60
  %64 = getelementptr inbounds nuw float, ptr %52, i64 %61
  store float 0.000000e+00, ptr %64, align 4
  %65 = add i64 %61, 1
  br label %60

66:                                               ; preds = %60
  br label %67

67:                                               ; preds = %66, %35
  %68 = insertvalue { ptr, ptr, i64 } poison, ptr %39, 0
  %69 = insertvalue { ptr, ptr, i64 } %68, ptr %41, 1
  %70 = insertvalue { ptr, ptr, i64 } %69, i64 0, 2
  %71 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %39, 0
  %72 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %71, ptr %41, 1
  %73 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %72, i64 %37, 2
  %74 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %73, i64 %51, 3, 0
  %75 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %74, i64 1, 4, 0
  %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %52, 0
  %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %52, 1
  %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2
  %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %51, 3, 0
  %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0
  %81 = call ptr @llvm.stacksave.p0()
  %82 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, ptr %82, align 8
  %83 = insertvalue { i64, ptr } { i64 1, ptr poison }, ptr %82, 1
  %84 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %80, ptr %84, align 8
  %85 = insertvalue { i64, ptr } { i64 1, ptr poison }, ptr %84, 1
  %86 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %83, ptr %86, align 8
  %87 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %85, ptr %87, align 8
  call void @memrefCopy(i64 4, ptr %86, ptr %87)
  call void @llvm.stackrestore.p0(ptr %81)
  br label %88

88:                                               ; preds = %91, %67
  %89 = phi i64 [ %98, %91 ], [ 0, %67 ]
  %90 = icmp slt i64 %89, 32
  br i1 %90, label %91, label %99

91:                                               ; preds = %88
  %92 = getelementptr inbounds nuw float, ptr %52, i64 %89
  %93 = load float, ptr %92, align 4
  %94 = getelementptr inbounds nuw float, ptr %23, i64 %89
  %95 = load float, ptr %94, align 4
  %96 = fmul float %93, %95
  %97 = getelementptr inbounds nuw float, ptr %52, i64 %89
  store float %96, ptr %97, align 4
  %98 = add i64 %89, 1
  br label %88

99:                                               ; preds = %88
  %100 = extractvalue { i64, ptr } %15, 1
  %101 = load ptr, ptr %100, align 8
  %102 = getelementptr ptr, ptr %100, i32 1
  %103 = load ptr, ptr %102, align 8
  %104 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %101, 0
  %105 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, ptr %103, 1
  %106 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %105, i64 %37, 2
  %107 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %106, i64 32, 3, 0
  %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %107, i64 1, 4, 0
  %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %52, 0
  %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, ptr %52, 1
  %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 0, 2
  %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 %51, 3, 0
  %113 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %112, i64 1, 4, 0
  %114 = insertvalue { ptr, ptr, i64 } poison, ptr %101, 0
  %115 = insertvalue { ptr, ptr, i64 } %114, ptr %103, 1
  %116 = insertvalue { ptr, ptr, i64 } %115, i64 0, 2
  %117 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } poison, ptr %101, 0
  %118 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %117, ptr %103, 1
  %119 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %118, i64 %37, 2
  %120 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %119, i64 %51, 3, 0
  %121 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %120, i64 1, 4, 0
  %122 = call ptr @llvm.stacksave.p0()
  %123 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %113, ptr %123, align 8
  %124 = insertvalue { i64, ptr } { i64 1, ptr poison }, ptr %123, 1
  %125 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %121, ptr %125, align 8
  %126 = insertvalue { i64, ptr } { i64 1, ptr poison }, ptr %125, 1
  %127 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %124, ptr %127, align 8
  %128 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %126, ptr %128, align 8
  call void @memrefCopy(i64 4, ptr %127, ptr %128)
  call void @llvm.stackrestore.p0(ptr %122)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smin.i64(i64, i64) #0

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smax.i64(i64, i64) #0

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #1

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore.p0(ptr) #1

attributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #1 = { nocallback nofree nosync nounwind willreturn }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
