#loc = loc("/home/devro/workspace/ts_sandbox/load.py":10:0)
#loc1 = loc(unknown)
#loc5 = loc("/home/devro/workspace/ts_sandbox/load.py":16:16)
#map = affine_map<(d0) -> (d0)>
#loc8 = loc("in_ptr"(#loc))
#loc9 = loc("t"(#loc))
#loc10 = loc("out_ptr"(#loc))
#loc11 = loc("size0"(#loc))
#loc14 = loc("x"(#loc5))
module {
  func.func @load(%arg0: memref<*xf32> {tt.divisibility = 16 : i32} loc("in_ptr"(#loc)), %arg1: memref<*xi32> {tt.divisibility = 16 : i32} loc("t"(#loc)), %arg2: memref<*xf32> {tt.divisibility = 16 : i32} loc("out_ptr"(#loc)), %arg3: i32 {tt.divisibility = 16 : i32} loc("size0"(#loc)), %arg4: i32 loc("/home/devro/workspace/ts_sandbox/load.py":10:0), %arg5: i32 loc("/home/devro/workspace/ts_sandbox/load.py":10:0), %arg6: i32 loc("/home/devro/workspace/ts_sandbox/load.py":10:0), %arg7: i32 loc("/home/devro/workspace/ts_sandbox/load.py":10:0), %arg8: i32 loc("/home/devro/workspace/ts_sandbox/load.py":10:0), %arg9: i32 loc("/home/devro/workspace/ts_sandbox/load.py":10:0)) {
    %cst = arith.constant 2.000000e+00 : f32 loc(#loc1)
    %c32 = arith.constant 32 : index loc(#loc1)
    %cst_0 = arith.constant 0.000000e+00 : f32 loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tensor.empty() : tensor<32xf32> loc(#loc1)
    %1 = linalg.fill ins(%cst : f32) outs(%0 : tensor<32xf32>) -> tensor<32xf32> loc(#loc1)
    %2 = arith.muli %arg7, %c32_i32 : i32 loc(#loc12)
    %3 = arith.index_cast %2 : i32 to index loc(#loc3)
    %reinterpret_cast = memref.reinterpret_cast %arg0 to offset: [%3], sizes: [32], strides: [1] : memref<*xf32> to memref<32xf32, strided<[1], offset: ?>> loc(#loc13)
    %4 = arith.addi %3, %c32 : index loc(#loc14)
    %5 = arith.index_cast %arg3 : i32 to index loc(#loc14)
    %6 = arith.minsi %4, %5 : index loc(#loc14)
    %7 = arith.maxsi %6, %3 : index loc(#loc14)
    %8 = arith.subi %7, %3 : index loc(#loc14)
    %alloc = memref.alloc() : memref<32xf32> loc(#loc14)
    %9 = arith.cmpi slt, %8, %c32 : index loc(#loc14)
    scf.if %9 {
      linalg.fill ins(%cst_0 : f32) outs(%alloc : memref<32xf32>) loc(#loc14)
    } loc(#loc14)
    %subview = memref.subview %reinterpret_cast[0] [%8] [1] : memref<32xf32, strided<[1], offset: ?>> to memref<?xf32, strided<[1], offset: ?>> loc(#loc14)
    %subview_1 = memref.subview %alloc[0] [%8] [1] : memref<32xf32> to memref<?xf32, strided<[1]>> loc(#loc14)
    memref.copy %subview, %subview_1 : memref<?xf32, strided<[1], offset: ?>> to memref<?xf32, strided<[1]>> loc(#loc14)
    %10 = bufferization.to_tensor %alloc restrict writable : memref<32xf32> to tensor<32xf32> loc(#loc14)
    %11 = linalg.generic {indexing_maps = [#map, #map, #map], iterator_types = ["parallel"]} ins(%10, %1 : tensor<32xf32>, tensor<32xf32>) outs(%10 : tensor<32xf32>) {
    ^bb0(%in: f32 loc("x"(#loc5)), %in_4: f32 loc(unknown), %out: f32 loc("x"(#loc5))):
      %12 = arith.mulf %in, %in_4 : f32 loc(#loc15)
      linalg.yield %12 : f32 loc(#loc15)
    } -> tensor<32xf32> loc(#loc15)
    %reinterpret_cast_2 = memref.reinterpret_cast %arg2 to offset: [%3], sizes: [32], strides: [1] : memref<*xf32> to memref<32xf32, strided<[1], offset: ?>> loc(#loc3)
    %extracted_slice = tensor.extract_slice %11[0] [%8] [1] : tensor<32xf32> to tensor<?xf32> loc(#loc7)
    %subview_3 = memref.subview %reinterpret_cast_2[0] [%8] [1] : memref<32xf32, strided<[1], offset: ?>> to memref<?xf32, strided<[1], offset: ?>> loc(#loc7)
    bufferization.materialize_in_destination %extracted_slice in writable %subview_3 : (tensor<?xf32>, memref<?xf32, strided<[1], offset: ?>>) -> () loc(#loc7)
    return loc(#loc)
  } loc(#loc)
} loc(#loc)
#loc2 = loc("/home/devro/workspace/ts_sandbox/load.py":12:20)
#loc3 = loc("/home/devro/workspace/ts_sandbox/load.py":19:23)
#loc4 = loc("/home/devro/workspace/ts_sandbox/load.py":16:25)
#loc6 = loc("/home/devro/workspace/ts_sandbox/load.py":18:15)
#loc7 = loc("/home/devro/workspace/ts_sandbox/load.py":19:32)
#loc12 = loc("offsets"(#loc2))
#loc13 = loc("x"(#loc4))
#loc15 = loc("result"(#loc6))

