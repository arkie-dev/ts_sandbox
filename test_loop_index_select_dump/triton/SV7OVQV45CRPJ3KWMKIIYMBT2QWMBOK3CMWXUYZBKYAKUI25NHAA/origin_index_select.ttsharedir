#loc = loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":29:0)
#loc13 = loc("in_ptr"(#loc))
#loc14 = loc("indices_ptr"(#loc))
#loc15 = loc("out_ptr"(#loc))
#loc16 = loc("dim"(#loc))
module {
  func.func @origin_index_select(%arg0: memref<*xf32> {tt.divisibility = 16 : i32} loc("in_ptr"(#loc)), %arg1: memref<*xi32> {tt.divisibility = 16 : i32} loc("indices_ptr"(#loc)), %arg2: memref<*xf32> {tt.divisibility = 16 : i32} loc("out_ptr"(#loc)), %arg3: i32 {tt.divisibility = 16 : i32} loc("dim"(#loc)), %arg4: i32 loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":29:0), %arg5: i32 loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":29:0), %arg6: i32 loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":29:0), %arg7: i32 loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":29:0), %arg8: i32 loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":29:0), %arg9: i32 loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":29:0)) {
    %c1 = arith.constant 1 : index loc(#loc1)
    %c0 = arith.constant 0 : index loc(#loc1)
    %c49299_i32 = arith.constant 49299 : i32 loc(#loc1)
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %c1024 = arith.constant 1024 : index loc(#loc1)
    %c1971940 = arith.constant 1971940 : index loc(#loc1)
    %c16 = arith.constant 16 : index loc(#loc1)
    %c0_i32 = arith.constant 0 : i32 loc(#loc1)
    %0 = arith.muli %arg7, %c49299_i32 : i32 loc(#loc17)
    %1 = arith.index_cast %0 : i32 to index loc(#loc3)
    scf.for %arg10 = %c0_i32 to %c49299_i32 step %c1024_i32  : i32 {
      %2 = arith.index_cast %arg10 : i32 to index loc(#loc18)
      %3 = arith.addi %1, %2 : index loc(#loc19)
      %reinterpret_cast = memref.reinterpret_cast %arg1 to offset: [%3], sizes: [1024], strides: [1] : memref<*xi32> to memref<1024xi32, strided<[1], offset: ?>> loc(#loc18)
      %4 = arith.addi %1, %c1024 : index loc(#loc20)
      %5 = arith.addi %4, %2 : index loc(#loc20)
      %6 = arith.minsi %5, %c1971940 : index loc(#loc20)
      %7 = arith.maxsi %6, %3 : index loc(#loc20)
      %8 = arith.subi %7, %3 : index loc(#loc20)
      %alloc = memref.alloc() : memref<1024xi32> loc(#loc20)
      %9 = arith.cmpi slt, %8, %c1024 : index loc(#loc20)
      scf.if %9 {
        linalg.fill ins(%c0_i32 : i32) outs(%alloc : memref<1024xi32>) loc(#loc20)
      } loc(#loc20)
      %subview = memref.subview %reinterpret_cast[0] [%8] [1] : memref<1024xi32, strided<[1], offset: ?>> to memref<?xi32, strided<[1], offset: ?>> loc(#loc20)
      %subview_0 = memref.subview %alloc[0] [%8] [1] : memref<1024xi32> to memref<?xi32, strided<[1]>> loc(#loc20)
      memref.copy %subview, %subview_0 : memref<?xi32, strided<[1], offset: ?>> to memref<?xi32, strided<[1]>> loc(#loc20)
      %10 = bufferization.to_tensor %alloc restrict writable : memref<1024xi32> to tensor<1024xi32> loc(#loc20)
      %11 = arith.minsi %8, %c1024 : index loc(#loc21)
      %alloc_1 = memref.alloc() : memref<1024x16xf32> loc(#loc21)
      %12 = arith.minsi %11, %c1024 : index loc(#loc21)
      scf.for %arg11 = %c0 to %12 step %c1 {
        %extracted = tensor.extract %10[%arg11] : tensor<1024xi32> loc(#loc21)
        %15 = arith.index_cast %extracted : i32 to index loc(#loc21)
        %16 = arith.muli %15, %c16 : index loc(#loc22)
        %reinterpret_cast_4 = memref.reinterpret_cast %arg0 to offset: [%16], sizes: [1, 16], strides: [16, 1] : memref<*xf32> to memref<1x16xf32, strided<[16, 1], offset: ?>> loc(#loc22)
        %subview_5 = memref.subview %alloc_1[%arg11, 0] [1, 16] [1, 1] : memref<1024x16xf32> to memref<1x16xf32, strided<[16, 1], offset: ?>> loc(#loc21)
        memref.copy %reinterpret_cast_4, %subview_5 : memref<1x16xf32, strided<[16, 1], offset: ?>> to memref<1x16xf32, strided<[16, 1], offset: ?>> loc(#loc21)
      } loc(#loc21)
      %13 = bufferization.to_tensor %alloc_1 restrict writable : memref<1024x16xf32> to tensor<1024x16xf32> loc(#loc21)
      %14 = arith.muli %3, %c16 : index loc(#loc10)
      %reinterpret_cast_2 = memref.reinterpret_cast %arg2 to offset: [%14], sizes: [1024, 16], strides: [16, 1] : memref<*xf32> to memref<1024x16xf32, strided<[16, 1], offset: ?>> loc(#loc11)
      %extracted_slice = tensor.extract_slice %13[0, 0] [%11, 16] [1, 1] : tensor<1024x16xf32> to tensor<?x16xf32> loc(#loc12)
      %subview_3 = memref.subview %reinterpret_cast_2[0, 0] [%11, 16] [1, 1] : memref<1024x16xf32, strided<[16, 1], offset: ?>> to memref<?x16xf32, strided<[16, 1], offset: ?>> loc(#loc12)
      bufferization.materialize_in_destination %extracted_slice in writable %subview_3 : (tensor<?x16xf32>, memref<?x16xf32, strided<[16, 1], offset: ?>>) -> () loc(#loc12)
    } loc(#loc4)
    return loc(#loc)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":32:31)
#loc3 = loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":41:31)
#loc4 = loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":33:35)
#loc5 = loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":36:40)
#loc6 = loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":34:52)
#loc7 = loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":36:47)
#loc8 = loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":40:87)
#loc9 = loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":40:68)
#loc10 = loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":41:48)
#loc11 = loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":41:59)
#loc12 = loc("/home/devro/workspace/ts_sandbox/test_loop_index_select.py":41:87)
#loc17 = loc("g_begin"(#loc2))
#loc18 = loc("indices"(#loc5))
#loc19 = loc("g_idx"(#loc6))
#loc20 = loc("indices"(#loc7))
#loc21 = loc("tmp_buf"(#loc8))
#loc22 = loc("tmp_buf"(#loc9))

